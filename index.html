<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Antigravity | Precise Physics</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f8f9fa; font-family: 'Google Sans', sans-serif; }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 0; }
        
        /* UI å±‚ */
        .ui-layer { position: relative; z-index: 10; width: 100%; height: 100vh; pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        header { pointer-events: auto; background: rgba(255,255,255,0.95); backdrop-filter: blur(20px); padding: 50px 70px; border-radius: 24px; box-shadow: 0 10px 40px rgba(0,0,0,0.06); text-align: center; border: 1px solid rgba(255,255,255,0.5); }
        h1 { margin: 0; color: #1f1f1f; font-size: 3.5rem; letter-spacing: -1.5px; font-weight: 600; }
        p.subtitle { margin-top: 10px; color: #5f6368; font-size: 1.1rem; }
        
        .gallery-container { display: none; } /* éšè—åŸæ¥çš„ç”»å»Š */
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div class="ui-layer">
        <header>
            <h1>Antigravity</h1>
            <p class="subtitle">Experience the new way to build</p>
        </header>
    </div>

    <div class="gallery-container" id="gallery"></div>

    <script>
        /**
         * ğŸŒŠ Google Antigravity V4: Critical Damping (ä¸´ç•Œé˜»å°¼)
         * å½»åº•æ¶ˆé™¤"æœå†»"å›å¼¹ï¼Œæ¨¡æ‹Ÿé«˜ç²˜åº¦æµä½“/ç£æµä½“æ‰‹æ„Ÿã€‚
         */
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // âš™ï¸ æ ¸å¿ƒç‰©ç†å‚æ•° (è°ƒæ•™æ‰‹æ„Ÿçš„å…³é”®)
        const CONFIG = {
            pointDist: 28,       // ç‚¹é—´è· (Poisson Disk å¯†åº¦)
            color: '#4285F4',    // Google Blue
            
            // ğŸ”¥ æ‹’ç»æœå†»çš„æ ¸å¿ƒå‚æ•° ğŸ”¥
            mouseRadius: 200,    // é¼ æ ‡å½±å“èŒƒå›´
            mouseForce: 0.15,    // æ¨å¼€çš„åŠ›åº¦
            friction: 0.85,      // å¼ºé˜»å°¼ (0.9æ˜¯æ»‘ï¼Œ0.8æ˜¯ç²˜)
            returnSpeed: 0.08,   // å›ä½é€Ÿåº¦ (è¶Šå°è¶Šæ…¢ï¼Œä½†ä¹Ÿè¶Šç¨³)
            
            // è§†è§‰å¾®è°ƒ
            baseSize: 1.6,       // ç²’å­åŸºç¡€å¤§å°
            maxSize: 3.5         // ç²’å­å—åŠ›æ—¶æ”¾å¤§çš„æœ€å¤§å°ºå¯¸
        };

        let width, height;
        let particles = [];
        const mouse = { x: -5000, y: -5000 }; // åˆå§‹æ”¾åˆ°å±å¹•å¤–

        // -----------------------------------------------------------
        // ğŸ“ Poisson Disk Sampling (æ³Šæ¾ç›˜é‡‡æ ·ç®—æ³•) - è¿˜åŸ main.js é€»è¾‘
        // -----------------------------------------------------------
        function generatePoissonPoints(w, h, r) {
            const k = 30; 
            const cellSize = r / Math.sqrt(2);
            const gridW = Math.ceil(w / cellSize);
            const gridH = Math.ceil(h / cellSize);
            const grid = new Array(gridW * gridH).fill(-1);
            const active = [];
            const p = [];

            // åˆå§‹ç‚¹
            const x0 = Math.random() * w;
            const y0 = Math.random() * h;
            const i0 = Math.floor(x0 / cellSize);
            const j0 = Math.floor(y0 / cellSize);
            const pos0 = { x: x0, y: y0 };
            
            p.push(pos0);
            active.push(pos0);
            grid[i0 + j0 * gridW] = 0;

            while (active.length > 0) {
                const randIndex = Math.floor(Math.random() * active.length);
                const center = active[randIndex];
                let found = false;

                for (let i = 0; i < k; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * r + r;
                    const newX = center.x + Math.cos(angle) * dist;
                    const newY = center.y + Math.sin(angle) * dist;

                    if (newX >= 0 && newX < w && newY >= 0 && newY < h) {
                        const col = Math.floor(newX / cellSize);
                        const row = Math.floor(newY / cellSize);
                        let ok = true;

                        for (let xOff = -1; xOff <= 1; xOff++) {
                            for (let yOff = -1; yOff <= 1; yOff++) {
                                const idx = (col + xOff) + (row + yOff) * gridW;
                                const neighborIdx = grid[idx];
                                if (neighborIdx !== undefined && neighborIdx !== -1) {
                                    const neighbor = p[neighborIdx];
                                    const d = (newX - neighbor.x) ** 2 + (newY - neighbor.y) ** 2;
                                    if (d < r * r) ok = false;
                                }
                            }
                        }

                        if (ok) {
                            const newPoint = { x: newX, y: newY };
                            active.push(newPoint);
                            p.push(newPoint);
                            grid[col + row * gridW] = p.length - 1;
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) active.splice(randIndex, 1);
            }
            return p;
        }

        // -----------------------------------------------------------
        // ğŸ§ª ç²’å­é€»è¾‘
        // -----------------------------------------------------------
        class Particle {
            constructor(x, y) {
                this.ox = x; // åŸå§‹ä½ç½® (Origin)
                this.oy = y;
                this.x = x;  // å½“å‰ä½ç½®
                this.y = y;
                this.vx = 0; // é€Ÿåº¦
                this.vy = 0;
                this.s = CONFIG.baseSize; // å°ºå¯¸
            }

            update() {
                // 1. é¼ æ ‡æ’æ–¥é€»è¾‘
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                
                // é™åˆ¶ dist é˜²æ­¢é™¤ä»¥0
                if (dist < 1) dist = 1;

                let force = 0;
                let angle = 0;

                // åªæœ‰åœ¨èŒƒå›´å†…æ‰å—åŠ›
                if (dist < CONFIG.mouseRadius) {
                    // åŠ›çš„è®¡ç®—ï¼šè¶Šè¿‘è¶Šå¼ºï¼ŒäºŒæ¬¡æ–¹è¡°å‡ (å¹²è„†æœ‰åŠ›)
                    force = (1 - dist / CONFIG.mouseRadius) * CONFIG.mouseForce * 10;
                    angle = Math.atan2(dy, dx);
                    
                    // æ–½åŠ æ–¥åŠ›
                    this.vx += Math.cos(angle) * force;
                    this.vy += Math.sin(angle) * force;
                }

                // 2. å›å½’é€»è¾‘ (è¿™æ˜¯æ¶ˆé™¤æœå†»æ„Ÿçš„å…³é”®)
                // ä¸ä½¿ç”¨å¼¹ç°§(Hooke's Law)ï¼Œæ”¹ç”¨çº¿æ€§æ’å€¼é€¼è¿‘ (Lerp-like approach)
                // è¿™ç§åŠ›ä¼šè®©ç²’å­"æ­»"åœ¨åŸç‚¹ï¼Œè€Œä¸æ˜¯ç»•ç€åŸç‚¹éœ‡è¡
                this.vx += (this.ox - this.x) * CONFIG.returnSpeed;
                this.vy += (this.oy - this.y) * CONFIG.returnSpeed;

                // 3. å¼ºåŠ›é˜»å°¼
                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;

                // 4. æ›´æ–°ä½ç½®
                this.x += this.vx;
                this.y += this.vy;

                // 5. åŠ¨æ€å¤§å°ï¼šè¢«æ¨å¼€æ—¶å˜å¤§ä¸€ç‚¹ç‚¹
                const speed = Math.abs(this.vx) + Math.abs(this.vy);
                const targetSize = CONFIG.baseSize + Math.min(speed * 0.5, CONFIG.maxSize);
                this.s += (targetSize - this.s) * 0.1; // å¤§å°å˜åŒ–çš„å¹³æ»‘è¿‡æ¸¡
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.s, 0, Math.PI * 2);
                
                // é¢œè‰²é€æ˜åº¦éšé€Ÿåº¦å˜åŒ–ï¼ŒåŠ¨èµ·æ¥æ›´äº®
                const alpha = 0.4 + Math.min((Math.abs(this.vx) + Math.abs(this.vy)) * 0.2, 0.6);
                ctx.fillStyle = `rgba(66, 133, 244, ${alpha})`;
                ctx.fill();
            }
        }

        // -----------------------------------------------------------
        // ğŸ¬ ä¸»ç¨‹åº
        // -----------------------------------------------------------
        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            // ä½¿ç”¨æ³Šæ¾ç›˜é‡‡æ ·ç”Ÿæˆç‚¹
            const points = generatePoissonPoints(width, height, CONFIG.pointDist);
            
            particles = [];
            points.forEach(p => {
                particles.push(new Particle(p.x, p.y));
            });
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', init);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        
        // é¼ æ ‡ç¦»å¼€æ—¶æŠŠå¹²æ‰°æºç§»èµ°
        window.addEventListener('mouseleave', () => {
            mouse.x = -5000;
            mouse.y = -5000;
        });

        init();
        animate();
        
        
        // =========================================================
        // ğŸ–¼ï¸ ä¸šåŠ¡é€»è¾‘ï¼šè‡ªåŠ¨ç”Ÿæˆåˆ†ç±»æŒ‰é’® (ä¿ç•™ä½ çš„éœ€æ±‚)
        // =========================================================
        // è¿™é‡Œå¯ä»¥ç»§ç»­æ”¾ä½ ä¹‹å‰çš„ä½œå“é›†åŠ è½½é€»è¾‘...
        const categories = [
            { id: 'illustration', name: 'Commercial Illustration' }, 
            { id: 'character',    name: 'Character Design' },
            { id: 'scene',        name: 'Environment Art' },
            { id: 'sketch',       name: 'Sketches & Doodles' },
            { id: 'other',        name: 'Others' },
        ];
        // ... (å…¶ä½™é€»è¾‘çœç•¥ï¼Œä¸ºäº†ä¿æŒä»£ç æ•´æ´ï¼Œä½ å¯ä»¥æŠŠä¹‹å‰çš„é€»è¾‘è´´å›æ¥)

    </script>
</body>
</html>
