<!DOCTYPE html> 
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Antigravity | Radial Flow</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f8f9fa; font-family: 'Google Sans', sans-serif; }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 0; }
        
        /* UI 层 */
        .ui-layer { position: relative; z-index: 10; width: 100%; height: 100vh; pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        header { pointer-events: auto; background: rgba(255,255,255,0.95); backdrop-filter: blur(20px); padding: 50px 70px; border-radius: 24px; box-shadow: 0 10px 40px rgba(0,0,0,0.06); text-align: center; border: 1px solid rgba(255,255,255,0.5); }
        h1 { margin: 0; color: #1f1f1f; font-size: 3.5rem; letter-spacing: -1.5px; font-weight: 600; }
        p.subtitle { margin-top: 10px; color: #5f6368; font-size: 1.1rem; }
        
        .gallery-container { display: none; }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div class="ui-layer">
        <header>
            <h1>Antigravity</h1>
            <p class="subtitle">Pure Radial Diffusion — Jelly / silky motion</p>
        </header>
    </div>

    <div class="gallery-container" id="gallery"></div>

    <script>
        /**
         * 改进版本：水母式丝滑动效
         * - phase-driven motion (低频呼吸)
         * - smooth inertial return (lerp + friction)
         * - Poisson Disk 保持均匀分布
         * - soft glow via radial gradient and 'lighter' blending
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // ⚙️ 参数配置 (调教手感)
        const CONFIG = {
            // 粒子分布
            pointDist: 28,        // 点间距 (越小越密 / 性能开销)
            maxParticles: 1800,   // 上限（安全保护）
            
            // 鼠标 / 交互
            cursorRadius: 180,    // 鼠标影响半径
            pushStrength: 80,     // 推力强度（总体系数）
            pushFalloff: 0.9,     // 力的衰减（平滑）

            // 物理手感
            friction: 0.86,       // 阻尼（越接近 1 越顺滑但更粘）
            returnSpeed: 0.06,    // 回位速度 （越小越慢像粘稠液体）
            inertiaLerp: 0.12,    // 速度追随平滑度（0.0 - 1.0）

            // 视觉
            color: [66,133,244],  // Google Blue RGB
            baseSize: 1.2,
            glowSize: 12,

            // breathing & noise
            globalFreq: 0.18,     // 全局低频（呼吸频率）
            localFreqRange: [0.8, 1.6], // 每颗粒子的频率倍数在此范围
            noiseAmount: 0.6      // 微小高频扰动（细节，用作 curl / 微摆动）
        };

        let DPR = Math.max(1, window.devicePixelRatio || 1);
        let width, height;
        let particles = [];
        const mouse = { x: -9999, y: -9999, active: false };

        // -----------------------------
        // Poisson Disk Sampling (kept)
        // -----------------------------
        function generatePoissonPoints(w, h, r) {
            const k = 30;
            const cellSize = r / Math.sqrt(2);
            const gridW = Math.ceil(w / cellSize);
            const gridH = Math.ceil(h / cellSize);
            const grid = new Array(gridW * gridH).fill(-1);
            const active = [];
            const p = [];

            // start from center-ish to reduce edge clustering
            const x0 = Math.random() * w;
            const y0 = Math.random() * h;
            const i0 = Math.floor(x0 / cellSize);
            const j0 = Math.floor(y0 / cellSize);
            const pos0 = { x: x0, y: y0 };
            
            p.push(pos0);
            active.push(pos0);
            grid[i0 + j0 * gridW] = 0;

            while (active.length > 0) {
                const randIndex = Math.floor(Math.random() * active.length);
                const center = active[randIndex];
                let found = false;

                for (let i = 0; i < k; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = r + Math.random() * r;
                    const newX = center.x + Math.cos(angle) * dist;
                    const newY = center.y + Math.sin(angle) * dist;

                    if (newX >= 0 && newX < w && newY >= 0 && newY < h) {
                        const col = Math.floor(newX / cellSize);
                        const row = Math.floor(newY / cellSize);
                        let ok = true;

                        for (let xOff = -1; xOff <= 1; xOff++) {
                            for (let yOff = -1; yOff <= 1; yOff++) {
                                const idx = (col + xOff) + (row + yOff) * gridW;
                                if (idx >= 0 && idx < grid.length && grid[idx] !== -1) {
                                    const neighbor = p[grid[idx]];
                                    const d = (newX - neighbor.x) ** 2 + (newY - neighbor.y) ** 2;
                                    if (d < r * r) ok = false;
                                }
                            }
                        }

                        if (ok) {
                            const newPoint = { x: newX, y: newY };
                            active.push(newPoint);
                            p.push(newPoint);
                            grid[col + row * gridW] = p.length - 1;
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) active.splice(randIndex, 1);
                if (p.length >= CONFIG.maxParticles) break;
            }
            return p;
        }

        // -----------------------------
        // tiny deterministic noise (pseudo)
        // -----------------------------
        function hashTo(seed) {
            // returns in [0,1)
            return fract(Math.sin(seed * 127.1) * 43758.5453);
        }
        function fract(x) { return x - Math.floor(x); }
        function pseudoNoise(x, y) {
            const s = x * 12.9898 + y * 78.233;
            return hashTo(s);
        }

        // -----------------------------
        // Particle class (improved)
        // -----------------------------
        class Particle {
            constructor(x, y) {
                this.originX = x;
                this.originY = y;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;

                // phase-driven
                this.phase = Math.random() * Math.PI * 2;
                this.localFreq = lerp(CONFIG.localFreqRange[0], CONFIG.localFreqRange[1], Math.random());

                // noise seed -> create subtle differences per point
                this.seed = (x * 73856093) ^ (y * 19349663) ^ Math.floor(Math.random()*1000);

                // for soft target blending
                this.targetOffsetX = 0;
                this.targetOffsetY = 0;
            }

            computeLocalBreath(t) {
                // low-frequency breathing (value in [-1,1])
                return Math.sin( (t * CONFIG.globalFreq * this.localFreq) + this.phase );
            }

            update(t, dt) {
                // dt in seconds (clamped)
                // 1) compute breathing and tiny noise
                const breath = this.computeLocalBreath(t) * 0.6; // amplitude
                const n = (pseudoNoise(this.originX * 0.01 + t * 0.09, this.originY * 0.01) - 0.5) * CONFIG.noiseAmount;

                // 2) mouse radial push - compute desired offset (target)
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                let pushX = 0, pushY = 0;

                if (mouse.active && dist < CONFIG.cursorRadius) {
                    // normalized direction from mouse to particle
                    const nx = dx / (dist || 1);
                    const ny = dy / (dist || 1);

                    // push strength scales with closeness (smooth)
                    const force = Math.pow((CONFIG.cursorRadius - dist) / CONFIG.cursorRadius, 1.2);
                    const push = CONFIG.pushStrength * force * 0.01; // small scale

                    // add a curl term to make flow feel organic: rotate direction slightly by a sin depending on phase
                    const curl = Math.sin(this.phase + t * 0.8) * 0.35;
                    const rx = nx * Math.cos(curl) - ny * Math.sin(curl);
                    const ry = nx * Math.sin(curl) + ny * Math.cos(curl);

                    pushX = rx * push * (1 + breath * 0.4);
                    pushY = ry * push * (1 + breath * 0.4);
                }

                // if not active, very small passive wobble outward/inward based on breath
                const passiveX = (Math.cos(this.phase + t * 0.4) * 0.5 + n * 0.8) * breath * 0.6;
                const passiveY = (Math.sin(this.phase + t * 0.36) * 0.5 + n * 0.9) * breath * 0.6;

                // compose target offset (small)
                const targetOffX = pushX + passiveX;
                const targetOffY = pushY + passiveY;

                // smooth target blending (so target doesn't jump)
                this.targetOffsetX = lerp(this.targetOffsetX, targetOffX, 0.14);
                this.targetOffsetY = lerp(this.targetOffsetY, targetOffY, 0.14);

                // 3) velocity receives spring toward origin + target offset
                const desiredX = this.originX + this.targetOffsetX * CONFIG.pointDist * 0.9;
                const desiredY = this.originY + this.targetOffsetY * CONFIG.pointDist * 0.9;

                // spring force (return home)
                const ax = (desiredX - this.x) * CONFIG.returnSpeed;
                const ay = (desiredY - this.y) * CONFIG.returnSpeed;

                // apply acceleration to velocity with inertia smoothing
                this.vx = lerp(this.vx, this.vx + ax, CONFIG.inertiaLerp);
                this.vy = lerp(this.vy, this.vy + ay, CONFIG.inertiaLerp);

                // 4) friction / damping
                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;

                // 5) apply movement
                this.x += this.vx;
                this.y += this.vy;

                // slowly progress phase so motion evolves
                this.phase += 0.002 + 0.0005 * (this.localFreq - 1) + dt * 0.2;
            }

            draw(ctx, t) {
                // compute displacement to measure how "energized" this particle is
                const dx0 = this.x - this.originX;
                const dy0 = this.y - this.originY;
                const displacement = Math.sqrt(dx0*dx0 + dy0*dy0);

                // size & alpha based on displacement and breathing
                const size = CONFIG.baseSize + Math.min(displacement * 0.08, 4);
                const alpha = clamp(0.12 + Math.min(displacement * 0.06, 0.7), 0.08, 0.95);

                // draw glow via radial gradient
                const r = size * CONFIG.glowSize;
                const gx = this.x;
                const gy = this.y;
                const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, r);
                // inner strong, outer soft
                const col = CONFIG.color;
                g.addColorStop(0, `rgba(${col[0]},${col[1]},${col[2]},${alpha})`);
                g.addColorStop(0.45, `rgba(${col[0]},${col[1]},${col[2]},${alpha*0.55})`);
                g.addColorStop(1, `rgba(${col[0]},${col[1]},${col[2]},${0.02})`);

                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(gx, gy, r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // -----------------------------
        // helpers
        // -----------------------------
        function lerp(a, b, t) { return a + (b - a) * t; }
        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

        // -----------------------------
        // animation
        // -----------------------------
        let lastTime = performance.now();
        function resize() {
            DPR = Math.max(1, window.devicePixelRatio || 1);
            width = canvas.width = Math.floor(window.innerWidth * DPR);
            height = canvas.height = Math.floor(window.innerHeight * DPR);
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';

            // regenerate particles if size changed significantly
            regenerateParticles();
        }

        function regenerateParticles() {
            const w = Math.floor(window.innerWidth);
            const h = Math.floor(window.innerHeight);
            const points = generatePoissonPoints(w, h, CONFIG.pointDist);

            particles = points.slice(0, CONFIG.maxParticles).map(p => {
                // scale for DPR: keep origin in CSS pixel coordinates (we draw in physical pixels)
                // but we want behaviors in CSS pixels for interaction
                return new Particle(p.x, p.y);
            });
        }

        function animate(now) {
            const dtMs = now - lastTime;
            // clamp dt for stability
            const dt = Math.min(dtMs / 1000, 0.033);
            lastTime = now;
            const t = now * 0.001;

            // clear with a subtle background to keep UI readable
            ctx.clearRect(0, 0, width, height);

            // render pass: draw soft glow layer using additive blending
            ctx.save();
            ctx.scale(DPR, DPR); // draw in CSS pixels space (we used origin in CSS px)
            ctx.globalCompositeOperation = 'lighter'; // additive for glow
            // subtle global fade (if you want ghosting, can lower alpha)
            // draw all particles
            for (let i = 0; i < particles.length; i++) {
                particles[i].update(t, dt);
                particles[i].draw(ctx, t);
            }
            ctx.restore();

            // restore default composite for crisp UI on top
            ctx.globalCompositeOperation = 'source-over';

            requestAnimationFrame(animate);
        }

        // -----------------------------
        // interaction
        // -----------------------------
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.active = true;
        });

        window.addEventListener('mouseleave', () => {
            mouse.x = -9999;
            mouse.y = -9999;
            mouse.active = false;
        });

        // touch support
        window.addEventListener('touchmove', (ev) => {
            const t = ev.touches[0];
            if (t) {
                mouse.x = t.clientX;
                mouse.y = t.clientY;
                mouse.active = true;
            }
        }, { passive: true });

        window.addEventListener('touchend', () => {
            mouse.active = false;
            mouse.x = -9999;
            mouse.y = -9999;
        });

        window.addEventListener('resize', () => {
            // small debounce not necessary — regenerate quickly
            resize();
        });

        // initial
        resize();
        lastTime = performance.now();
        requestAnimationFrame(animate);

        // =========================================================
        // 业务逻辑保留（不改动）: categories etc...
        // =========================================================
        const categories = [
            { id: 'illustration', name: 'Commercial Illustration' }, 
            { id: 'character',    name: 'Character Design' },
            { id: 'scene',        name: 'Environment Art' },
            { id: 'sketch',       name: 'Sketches & Doodles' },
            { id: 'other',        name: 'Others' },
        ];
    </script>
</body>
</html>
